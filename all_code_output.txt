==== ./config.json ====
{
    "NETWORK_DATA_PATH": "state/network.json",
    "NETWORKS_FOLDER_PATH": "state/network/",
    "PEER_FOLDER_PATH": "state/peer/"

}==== ./state/network/images.json ====
{
  "name": "images",
  "peers": [],
  "write": true
}==== ./state/network/photos.json ====
{
  "name": "photos",
  "peers": [],
  "write": true
}==== ./state/network.json ====
{
  "networks": [
    "images",
    "photos"
  ]
}==== ./peercache/settings/settings.py ====
import json
from pydantic import BaseModel, Field


class Settings(BaseModel):
    NETWORK_DATA_PATH: str = Field(default=None)
    NETWORKS_FOLDER_PATH: str = Field(default=None)
    PEER_FOLDER_PATH: str = Field(default=None)

    @classmethod
    def from_json(cls, json_path: str) -> "Settings":
        with open(json_path, "r") as f:
            data = json.load(f)
        return cls(**data)


SETTINGS = Settings.from_json("config.json")
==== ./peercache/core/hashing.py ====
import hashlib
import bisect
from typing import List

def _h32(data: str) -> int:
    """32-bit stable hash."""
    return int(hashlib.md5(data.encode()).hexdigest()[:8], 16)

class ConsistentHashRing:
    """
    Consistent hashing with V virtual nodes per peer.
    """

    def __init__(self, peer_ids: List[str], virtual_nodes: int = 100):
        self.vnodes  = {}
        self.ring    = []              # sorted list of hashes
        for pid in peer_ids:
            for v in range(virtual_nodes):
                h = _h32(f"{pid}#{v}")
                self.vnodes[h] = pid
                self.ring.append(h)
        self.ring.sort()

    def get_n(self, key: str, n: int = 1) -> List[str]:
        """
        Return N distinct peer_ids responsible for 'key'.
        Used for replication factor R.
        """
        if not self.ring: return []
        h = _h32(key)
        idx = bisect.bisect(self.ring, h)
        result = []
        while len(result) < n:
            pid = self.vnodes[self.ring[idx % len(self.ring)]]
            if pid not in result:
                result.append(pid)
            idx += 1
        return result
==== ./peercache/parser/registry.py ====
import json
from pathlib import Path
from peercache.settings.settings import SETTINGS

_REG_PATH = Path(SETTINGS.PEER_FOLDER_PATH) / "registry.json"

def _load() -> set[str]:
    if _REG_PATH.exists():
        return set(json.loads(_REG_PATH.read_text()))
    return set()

def _save(peers: set[str]):
    _REG_PATH.parent.mkdir(parents=True, exist_ok=True)
    _REG_PATH.write_text(json.dumps(sorted(peers), indent=2))

def add(peer_id: str):
    peers = _load()
    peers.add(peer_id)
    _save(peers)

def remove(peer_id: str):
    peers = _load()
    peers.discard(peer_id)
    _save(peers)

def list_peers() -> list[str]:
    return sorted(_load())
==== ./peercache/parser/peer.py ====
import json
import subprocess
import time
from peercache.settings.settings import SETTINGS
from pymemcache.client.base import Client
from peercache.parser.registry import add as _reg_add, remove as _reg_rm


class Peer:
    def __init__(self, peer_id: str, port: int | None = None):
        self.id = peer_id
        self.port = port or 0
        self.path = SETTINGS.PEER_FOLDER_PATH / f"{self.id}.json"
        self._load_or_init()

    def _load_or_init(self):
        if self.path.exists():
            data = json.loads(self.path.read_text())
            self.port = data["port"]
        else:
            if self.port == 0:
                raise ValueError("Port must be supplied for new peer")
            self._save()

    def _save(self):
        self.path.parent.mkdir(parents=True, exist_ok=True)
        self.path.write_text(json.dumps({"id": self.id, "port": self.port}, indent=2))
        _reg_add(self.id) 

    def start(self, memory_mb: int = 64) -> str:
        subprocess.Popen(
            ["memcached", "-d", "-m", str(memory_mb), "-p", str(self.port)],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        time.sleep(0.2)
        return f"Peer {self.id} running on :{self.port}"

    def stop(self) -> str:
        subprocess.call(["pkill", "-f", f"memcached.*-p {self.port}"])
        _reg_rm(self.id) 
        return f"Peer {self.id} stopped."

    def _client(self) -> Client:
        return Client(("localhost", self.port), connect_timeout=1, timeout=1)

    def set(self, k: str, v: str):
        self._client().set(k, v)

    def get(self, k: str):
        return self._client().get(k)

    def stats(self) -> dict:
        return self._client().stats()
==== ./peercache/parser/network.py ====
import json
from pathlib import Path
from typing import List

from peercache.settings.settings import SETTINGS
from peercache.parser.peer   import Peer
from peercache.core.hashing import ConsistentHashRing


class Network:
    """
    A single Memcached network with a consistent-hash ring and optional replication.
    Each network is stored in state/network/<name>.json
    """
    def __init__(self, name: str, replication: int = 1, vnodes: int = 100) -> None:
        self.name         = name
        self.peers: List[str] = []
        self.write        = True
        self.replication  = replication       
        self.vnodes       = vnodes          
        self.file_path    = Path(SETTINGS.NETWORKS_FOLDER_PATH) / f"{self.name}.json"

        self._load_or_initialize()
        self._build_ring()

    def _load_or_initialize(self):
        if self.file_path.exists():
            try:
                with open(self.file_path, "r") as f:
                    data = json.load(f)
                self.peers       = data.get("peers", [])
                self.write       = data.get("write", True)
                self.replication = data.get("replication", self.replication)
                self.vnodes      = data.get("vnodes",      self.vnodes)
            except (json.JSONDecodeError, IOError):
                self.peers = []
        else:
            self._save()

    def _save(self):
        payload = {
            "name":        self.name,
            "peers":       self.peers,
            "write":       self.write,
            "replication": self.replication,
            "vnodes":      self.vnodes,
        }
        self.file_path.parent.mkdir(parents=True, exist_ok=True)
        self.file_path.write_text(json.dumps(payload, indent=2))

    def _build_ring(self):
        self.ring = ConsistentHashRing(self.peers, virtual_nodes=self.vnodes)

    def add_peer(self, peer_id: str) -> str:
        if peer_id not in self.peers:
            self.peers.append(peer_id)
            self._save()
            self._build_ring()
            return f"Peer '{peer_id}' added to network '{self.name}'."
        return f"Peer '{peer_id}' already exists in network '{self.name}'."

    def remove_peer(self, peer_id: str) -> str:
        if peer_id in self.peers:
            self.peers.remove(peer_id)
            self._save()
            self._build_ring()
            return f"Peer '{peer_id}' removed from network '{self.name}'."
        return f"Peer '{peer_id}' not found in network '{self.name}'."

    def cache_set(self, key: str, value: str) -> str:
        if not self.peers:
            return "No peers available."
        targets = self.ring.get_n(key, self.replication)
        for pid in targets:
            Peer(pid).set(key, value)
        return f"SET {key} replicated to {targets}"

    def cache_get(self, key: str) -> str:
        if not self.peers:
            return "No peers available."
        for pid in self.ring.get_n(key, self.replication):
            val = Peer(pid).get(key)
            if val is not None:
                return val.decode()
        return "MISS"

    def stats(self) -> str:
        return (
            f"Network: {self.name}\n"
            f"Peers  : {', '.join(self.peers) if self.peers else 'None'}\n"
            f"Write  : {self.write}\n"
            f"Replicas: {self.replication} | VNodes: {self.vnodes}"
        )

    def __str__(self) -> str:
        return self.stats()
==== ./peercache/parser/manager.py ====
import json
from pathlib import Path
from peercache.parser.network import Network
from peercache.settings.settings import SETTINGS


class NetworkManager:
    """
    Manages a collection of named Memcached-like networks.
    Loads and saves network state from the path specified in Settings.
    """

    def __init__(self) -> None:
        """
        Initialize the NetworkManager, loading persisted networks if available.

        Args:
            settings (Settings): Configuration settings instance.
        """
        self.networks: set[Network] = set()
        self.write: bool = True
        self._load()

    def _load(self) -> None:
        """
        Load networks from the JSON file specified by settings.NETWORK_DATA_PATH.
        """
        data_path = Path(SETTINGS.NETWORK_DATA_PATH)
        if data_path.exists():
            try:
                data = json.loads(data_path.read_text())
                self.networks = {Network(name) for name in data.get("networks", [])}
            except Exception:
                self.networks = set()
        else:
            self.networks = set()

    def _save(self) -> None:
        """
        Save current networks to the JSON file specified by settings.NETWORK_DATA_PATH.
        """
        data_path = Path(SETTINGS.NETWORK_DATA_PATH)
        names = sorted(n.name for n in self.networks)
        data_path.write_text(json.dumps({"networks": names}, indent=2))

    def create_network(self, name: str) -> str:
        """
        Create a new network with the given name and persist changes.

        Args:
            name (str): Network name to create.

        Returns:
            str: Result message.
        """
        if name not in {n.name for n in self.networks}:
            self.networks.add(Network(name))
            self._save()
            return f"Network '{name}' created successfully."
        return f"Network '{name}' already exists."

    def delete_network(self, name: str) -> str:
        """
        Delete the network with the given name and persist changes.

        Args:
            name (str): Network name to delete.

        Returns:
            str: Result message.
        """
        for network in list(self.networks):
            if network.name == name:
                self.networks.remove(network)

                network_file = Path(SETTINGS.NETWORKS_FOLDER_PATH) / f"{name}.json"
                if network_file.exists():
                    network_file.unlink()

                self._save()
                return f"Network '{name}' deleted successfully."
        return f"Network '{name}' not found."

    def list_networks(self) -> str:
        """
        Return a formatted string listing all current network names.

        Returns:
            str: Networks summary.
        """
        names = sorted(n.name for n in self.networks)
        if names:
            return "Networks:\n" + "\n".join(f"  - {n}" for n in names)
        return "No networks available."

    def __str__(self) -> str:
        names = sorted(n.name for n in self.networks)
        return (
            "NetworkManager:\n"
            f"  Networks: {', '.join(names) if names else 'None'}\n"
            f"  Write   : {self.write}"
        )
==== ./main.py ====
import typer

from peercache.parser.peer import Peer
from peercache.parser.network import Network
from peercache.parser.manager import NetworkManager
from peercache.parser.registry import list_peers as registry_list


app = typer.Typer()
manager: NetworkManager = NetworkManager()


@app.command("manager")
def network_manager(
    show: bool = typer.Option(False, "--show", help="Show all current networks."),
    create: str = typer.Option(None, "--create", help="Create a new network."),
    delete: str = typer.Option(None, "--delete", help="Delete an existing network."),
):
    if show:
        typer.echo(manager.list_networks())
    elif create:
        typer.echo(manager.create_network(create))
    elif delete:
        typer.echo(manager.delete_network(delete))
    else:
        typer.echo(
            "Please provide one of the following options: --show, --create <name>, or --delete <name>."
        )


@app.command("network")
def network_command(
    name: str = typer.Argument(..., help="Name of the network."),
    show: bool = typer.Option(False, "--show", help="Show network stats."),
    add: str = typer.Option(None, "--add", help="Add a peer to the network."),
    remove: str = typer.Option(
        None, "--remove", help="Remove a peer from the network."
    ),
):
    """
    Operate on an individual network by name.
    """
    if name not in {n.name for n in manager.networks}:
        typer.echo(f"Network '{name}' not found.")
        raise typer.Exit(code=1)

    network = Network(name)

    if show:
        typer.echo(network.stats())
    elif add:
        typer.echo(network.add_peer(add))
    elif remove:
        typer.echo(network.remove_peer(remove))
    else:
        typer.echo("Use one of: --show, --add <peer>, or --remove <peer>.")

@app.command("peer")
def peer_command(
    start: str = typer.Option(None, "--start", help="Start a new peer with given ID."),
    stop: str = typer.Option(None, "--stop", help="Stop a peer with given ID."),
    status: bool = typer.Option(False, "--status", help="Show all active peers.")
):

    if start:
        peer = Peer(start)
        peer.start()
        typer.echo(f"Started peer '{start}'.")
    elif stop:
        peer = Peer(stop)
        peer.stop()
        typer.echo(f"Stopped peer '{stop}'.")
    elif status:
        peers = registry_list()
        if not peers:
            typer.echo("No active peers.")
        else:
            typer.echo("Active peers:\n" + "\n".join(f"  - {p}" for p in peers))
    else:
        typer.echo("Use one of: --start <id>, --stop <id>, or --status.")


if __name__ == "__main__":
    app()
